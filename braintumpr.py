# -*- coding: utf-8 -*-
"""BrainTUMPR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gLrwJ5DvsNu5JAT0LHdAtBknwdOgCOTp

FOR LEARNING PURPOSE(HOW TO SHOW A IMAGE)
"""

from google.colab import drive
drive.mount('/content/drive')

from skimage import io,filters
from matplotlib import pyplot as plt

img = io.imread('/content/drive/MyDrive/Brain_Tumor/no/No12.jpg') #Do not have any brain tumor
gaussina_img = filters.gaussian(img,sigma=2)
plt.imshow(gaussina_img)

img = io.imread('/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg') #have tumor
gaussina_img = filters.gaussian(img,sigma=2)
plt.imshow(gaussina_img)

"""READING IMAGES(SHAPE DEFINE)"""

from skimage import io
img = io.imread('/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg') #have tumor
print(img.shape) # y,x and number od channels# those channels are red,green and blue

# convert image using float
from skimage import img_as_float
img2 = img_as_float(img)

"""READING PROPERTY IMAGES

VIEWING 2D IMAGES IN PYTHON
"""

from skimage import io
img = io.imread('/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg') #have tumor
io.imshow(img)

from matplotlib import pyplot as plt
plt.imshow(img)

img = io.imread('/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg',as_gray =True)

plt.imshow(img,cmap ="hot")

plt.imshow(img,cmap ="jet")

plt.imshow(img,cmap ="Blues")

#Entire four figure in one frame
img_gray = io.imread('/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg',as_gray =True)
fig = plt.figure(figsize=(10,10))

ax1 = fig.add_subplot(2,2,1)
ax1.imshow(img_gray,cmap='hot')
ax1.title.set_text('1st')

ax2 = fig.add_subplot(2,2,2)
ax2.imshow(img_gray,cmap='jet')
ax2.title.set_text('2nd')

ax3 = fig.add_subplot(2,2,3)
ax3.imshow(img_gray,cmap='Blues')
ax3.title.set_text('3rd')

ax2 = fig.add_subplot(2,2,4)
ax2.imshow(img_gray,cmap='gray')
ax2.title.set_text('4th')

"""TOMORROW WILL START FROM 29....."""

import numpy as np
from PIL import Image
img = np.asarray(Image.open("/content/drive/MyDrive/Brain_Tumor/yes/y0.jpg"))
print(img)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

import os

path = os.listdir('/content/drive/MyDrive/Brain_Tumor')
classes = {'/content/drive/MyDrive/Brain_Tumor/no' :0 ,'/content/drive/MyDrive/Brain_Tumor/yes' : 1 }

import cv2
X = []
Y = []
for cls in classes:
    pth ='/content/drive/MyDrive/Brain_Tumor'
    for j in os.listdir(pth):
        ig = cv2.imread(pth+'/' +j,0)
        #ig = cv2.resize(ig,(400,400))
        X.append(ig)
        Y.append(classes[cls])

np.unique(Y)

X = np.array(X)
Y = np.array(Y)

pd.Series(Y).value_counts()

X.shape

import os
Root = "/content/drive/MyDrive/Brain_Tumor"
os.chdir(Root)

# Commented out IPython magic to ensure Python compatibility.
#Import the necessary libraries first

import tensorflow as tf
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
from tensorflow.keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.metrics import categorical_crossentropy
from keras.models import Sequential, Model
from keras.layers import Conv2D, MaxPooling2D,GlobalAveragePooling2D
from keras.layers import Activation, Dropout, BatchNormalization, Flatten, Dense, AvgPool2D,MaxPool2D
from keras.models import Sequential, Model
from tensorflow.keras.optimizers import Adam
import cv2

data = '/content/drive/MyDrive/Brain_Tumor'
No_brain_tumor = '/content/drive/MyDrive/Brain_Tumor/no'
Yes_brain_tumor = '/content/drive/MyDrive/Brain_Tumor/yes'

dirlist=[No_brain_tumor, Yes_brain_tumor]
classes=['0', '1']
filepaths=[]
labels=[]
for i,j in zip(dirlist, classes):
    filelist=os.listdir(i)
    for f in filelist:
        filepath=os.path.join (i,f)
        filepaths.append(filepath)
        labels.append(j)
print ('filepaths: ', len(filepaths), '   labels: ', len(labels))

Files=pd.Series(filepaths, name='filepaths')
Label=pd.Series(labels, name='labels')
df=pd.concat([Files,Label], axis=1)
df=pd.DataFrame(np.array(df), columns = ['filepaths', 'labels'])
df.head()
df.tail()



print(df['labels'].value_counts())

#visualize brain tumor images

plt.figure(figsize=(12,8))
for i in range(15):
    random = np.random.randint(1,len(df))
    plt.subplot(3,5,i+1)
    plt.imshow(cv2.imread(df.loc[random,"filepaths"]))
    plt.title(df.loc[random, "labels"], size = 15, color = "white") 
    plt.xticks([])
    plt.yticks([])
    
plt.show()



from sklearn.model_selection import train_test_split

train, test = train_test_split(df, train_size=0.95, random_state=0)
train_new, valid = train_test_split(train, train_size=0.90, random_state=0)

print(f"train set shape: {train_new.shape}")
print(f"test set shape: {test.shape}")
print(f"validation set shape: {valid.shape}")

train_datagen = ImageDataGenerator(rescale = 1./255.,rotation_range = 40, width_shift_range = 0.2, height_shift_range = 0.2, 
                                   shear_range = 0.2, zoom_range = 0.2, horizontal_flip = True, vertical_flip =True)
test_datagen = ImageDataGenerator(rescale = 1.0/255.)

train_gen = train_datagen.flow_from_dataframe(dataframe = train_new,
                                              x_col = 'filepaths', y_col ='labels',
                                              target_size = (224,224), batch_size = 32, 
                                              class_mode = 'binary', shuffle = True)
val_gen = train_datagen.flow_from_dataframe(valid, 
                                            target_size=(224,224), x_col = 'filepaths', y_col ='labels', 
                                            class_mode='binary',
                                            batch_size= 16, shuffle=True)
test_gen = test_datagen.flow_from_dataframe(test,
                                            target_size = (224,224), x_col = 'filepaths', y_col ='labels',
                                             class_mode = 'binary',
                                            batch_size = 16, shuffle = False)

train_gen.class_indices

"""ResNetV2"""

from tensorflow import keras
base_model = keras.applications.ResNet50V2(
    weights="imagenet",  # Load weights pre-trained on ImageNet.
    input_shape=(224, 224, 3),
    include_top=False,
)  # Do not include the ImageNet classifier at the top.

# Freeze the base_model
base_model.trainable = False

# Create new model on top
inputs = keras.Input(shape=(224, 224, 3))


# The base model contains batchnorm layers. We want to keep them in inference mode
# when we unfreeze the base model for fine-tuning, so we make sure that the
# base_model is running in inference mode here.
x = base_model(inputs, training=False)
x = keras.layers.GlobalAveragePooling2D()(x)
x = keras.layers.Dropout(0.2)(x)  # Regularize with dropout
outputs = keras.layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(inputs, outputs)

model.summary()

callbacks = [
    tf.keras.callbacks.ModelCheckpoint("Tumor_classifier_model.h5", save_best_only=True, verbose = 0)
]





model.compile(loss='binary_crossentropy', optimizer=Adam(learning_rate= 0.0001), metrics=['accuracy'])


history = model.fit(train_gen, validation_data = val_gen, epochs = 100, 
                    callbacks = [callbacks], verbose = 1)

import keras
from keras.models import Sequential,Input,Model
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from tensorflow.keras.layers import Conv1D,BatchNormalization,LeakyReLU,MaxPool1D,GlobalAveragePooling1D,Dense,Dropout,AveragePooling1D
from keras.layers.advanced_activations import LeakyReLU
from tensorflow.keras.optimizers import Adam
import tensorflow as tf

batch_size = 64
epochs = 20
num_classes = 2



fashion_model.compile('adam',loss=keras.losses.categorical_crossentropy ,metrics =['accuracy'])

fashion_model = Sequential()
fashion_model.add(Conv2D(32, kernel_size=(3, 3),activation='linear',input_shape=(224,224,1),padding='same'))
fashion_model.add(LeakyReLU(alpha=0.1))
fashion_model.add(MaxPooling2D((2, 2),padding='same'))
fashion_model.add(Conv2D(64, (3, 3), activation='linear',padding='same'))
fashion_model.add(LeakyReLU(alpha=0.1))
fashion_model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
fashion_model.add(Conv2D(128, (3, 3), activation='linear',padding='same'))
fashion_model.add(LeakyReLU(alpha=0.1))                  
fashion_model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
fashion_model.add(Flatten())
fashion_model.add(Dense(128, activation='linear'))
fashion_model.add(LeakyReLU(alpha=0.1))                  
fashion_model.add(Dense(num_classes, activation='softmax'))

fashion_model.compile(loss=keras.losses.categorical_crossentropy, optimizer=tf.optimizers.Adam(),metrics=['accuracy'])

fashion_model.summary()

fashion_train = fashion_model.fit(train_gen , batch_size=batch_size,epochs=epochs,verbose=1,validation_data=(val_gen ))